<!DOCTYPE html>
<html lang="CN">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
    <title>Composition API(常用部分)</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="nav">
        
        <div>
          <p class="menu">Git</p>
          <ul>
            <li>
              
              <a class="menu-item" href="04dd9b66-21a0-4022-ace2-88128581e905.html">
                Git 学习
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">JavaScript</p>
          <ul>
            <li>
              
              <a class="menu-item" href="7780599f-93a0-4043-bd09-d501fe5c0957.html">
                JavaScript异步处理
              </a>
              
              <a class="menu-item" href="f13ba8a9-5097-4af1-8b45-0992d1381622.html">
                JavaScript数组
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">linux</p>
          <ul>
            <li>
              
              <a class="menu-item" href="2bdc5f72-7bc5-45e1-843c-81374ef92b8d.html">
                ArchLinux安装美化之系统安装
              </a>
              
              <a class="menu-item" href="b9ed9c39-de85-47dc-990f-08a46225027c.html">
                Linux 压缩和解压缩命令
              </a>
              
              <a class="menu-item" href="24508bb6-1c34-45e7-809f-ce09a3046113.html">
                Linux 网络配置
              </a>
              
              <a class="menu-item" href="a98d50e4-6cc4-47b8-a564-4ae0d707db1e.html">
                nvm 安装与配置
              </a>
              
              <a class="menu-item" href="604445db-1794-4ef0-9c9c-1059c56437ba.html">
                oh-my-zsh 安装与配置
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">MongDB</p>
          <ul>
            <li>
              
              <a class="menu-item" href="18fb8215-7617-4cf8-b22b-9957f66c5893.html">
                MongoDB基本使用
              </a>
              
              <a class="menu-item" href="ec8c8c89-6775-4f80-bae5-83b59b50dac0.html">
                MongoDB权限配置
              </a>
              
              <a class="menu-item" href="8647bad3-78b4-4f07-8fff-35e9db7d8da6.html">
                MongoDB进阶
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">Nginx</p>
          <ul>
            <li>
              
              <a class="menu-item" href="50848776-a5be-4d0b-86d3-62e82c5d842a.html">
                Nginx安装
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">npm</p>
          <ul>
            <li>
              
              <a class="menu-item" href="b24236c6-e4dd-422a-8a47-246a1c4a1ef8.html">
                npm-workspace
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">PowerShell</p>
          <ul>
            <li>
              
              <a class="menu-item" href="9907b1a0-41e4-4117-881d-483ca01607fa.html">
                PoserShell 学习
              </a>
              
              <a class="menu-item" href="f1ebd3f6-0685-4af2-8e8b-fbfd87a8b06f.html">
                powershell 命令
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">rust</p>
          <ul>
            <li>
              
              <a class="menu-item" href="ce04efaf-8b85-4342-81fb-80334e7f4a62.html">
                Rust 基础
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">TypeScript</p>
          <ul>
            <li>
              
              <a class="menu-item" href="74401e20-7f5a-4cd6-a26c-6223819f96ca.html">
                TypeScript 基本项目搭建
              </a>
              
              <a class="menu-item" href="0ebcd04c-8c38-4e13-bac6-4c1c70151b02.html">
                TypeScript类型与配置笔记
              </a>
              
              <a class="menu-item" href="4e695865-22c1-43f3-94d2-98e7e1582854.html">
                TypeScript面向对象笔记
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">vscode</p>
          <ul>
            <li>
              
              <a class="menu-item" href="d0d823db-24ce-4e71-b8f0-390fbbd15a75.html">
                vscode配置
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">vue3</p>
          <ul>
            <li>
              
              <a class="menu-item" href="fa85d9a8-1069-4342-81d9-e0ff0ee25f71.html">
                Composition API(其它部分)
              </a>
              
              <a class="menu-item" href="6904e5fe-e1ee-4fa9-b4fb-ffd7c443235a.html">
                Composition API(常用部分)
              </a>
              
              <a class="menu-item" href="fc217708-8e1c-42b7-968e-fba530aa0d64.html">
                Vue3 新组件
              </a>
              
              <a class="menu-item" href="08d2855d-2fba-4544-887b-15cedbbabe4e.html">
                vue3快速上手
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">webpack</p>
          <ul>
            <li>
              
              <a class="menu-item" href="c81657b3-b382-4a26-8c1a-fa4741f44861.html">
                vue+ts+eslint前端项目搭建
              </a>
              
              <a class="menu-item" href="5d096691-64d6-4704-8e8c-fa0cbebdda8d.html">
                webpack + vue 企业级项目搭建
              </a>
              
              <a class="menu-item" href="0b88c60d-38ba-4bd0-a3c9-7b6bf0d1f62e.html">
                webpack
              </a>
              
              <a class="menu-item" href="302d11a7-d295-4ba0-879f-63779df8c279.html">
                webpack配置
              </a>
              
              <a class="menu-item" href="4716ec92-4f87-4733-bfa4-37353175552c.html">
                前端常用
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">Windows</p>
          <ul>
            <li>
              
              <a class="menu-item" href="4c96ec1d-6e1b-405a-a01c-b693020edb93.html">
                Windows Terminal设置代理
              </a>
              
              <a class="menu-item" href="06f75a60-76b5-4e72-a820-3325800d9d89.html">
                Windows安装优化
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">其它</p>
          <ul>
            <li>
              
              <a class="menu-item" href="cbcd108e-b08f-4b89-92ad-213b10b18086.html">
                mustache模板引擎
              </a>
              
              <a class="menu-item" href="3d1dda8b-67c9-4a2b-b984-3d60e59cf509.html">
                双向数据绑定
              </a>
              
              <a class="menu-item" href="83b423b0-396d-4753-827f-bb9fa110a4e9.html">
                抽象语法树
              </a>
              
              <a class="menu-item" href="e90b0ae2-c418-4470-82c7-5af9f11aea76.html">
                虚拟DOM与diff算法
              </a>
              
            </li>
          </ul>
        </div>
        
        <div>
          <p class="menu">打包构建工具</p>
          <ul>
            <li>
              
              <a class="menu-item" href="2f7bc079-6ab0-4423-b805-d7fb542fbda3.html">
                Grunt
              </a>
              
              <a class="menu-item" href="b66c16d5-e252-4f28-a58c-4d9bc16c313a.html">
                Gulp
              </a>
              
              <a class="menu-item" href="db851e7e-8714-449f-9460-91b814d18eb3.html">
                Rollup
              </a>
              
            </li>
          </ul>
        </div>
        
      </div>
      <div class="content">
        
        <div><h1 id="composition-api常用部分">Composition API(常用部分)</h1>
<h2 id="composition-api常用部分-1">Composition API(常用部分)</h2>
<h3 id="1、setup">1、setup</h3>
<ul>
<li>新的 option, 所有的组合 API 函数都在此使用, 只在初始化时执行一次</li>
<li>函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用</li>
</ul>
<h3 id="2、ref">2、ref</h3>
<ul>
<li>作用: 定义一个数据的响应式</li>
<li>语法: const xxx = ref(initValue):<ul>
<li>创建一个包含响应式数据的引用(reference)对象</li>
<li>js 中操作数据: xxx.value</li>
<li>模板中操作数据: 不需要.value</li>
</ul>
</li>
<li>一般用来定义一个基本类型的响应式数据</li>
</ul>
<p><strong>vue3 实现点击按钮更新数据：</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h2&gt;setup与ref使用&lt;/h2&gt;
    &lt;h3&gt;{{ count }}&lt;/h3&gt;
    &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, ref } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        let count = ref(1);

        function update() {
            count.value++;
        }

        return {
            count,
            update,
        };
    },
});
&lt;/script&gt;
</code></pre>
<p><strong>vue2 实现点击按钮更新数据：</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h2&gt;setup与ref使用&lt;/h2&gt;
    &lt;h3&gt;{{ count }}&lt;/h3&gt;
    &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    data() {
        return {
            count: 1,
        };
    },
    methods: {
        update() {
            this.count++;
        },
    },
});
&lt;/script&gt;
</code></pre>
<h3 id="3、reactive">3、reactive</h3>
<ul>
<li>作用: 定义多个数据的响应式</li>
<li>const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象</li>
<li>响应式转换是“深层的”：会影响对象内部所有嵌套的属性</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h2&gt;reactive基本使用&lt;/h2&gt;
    &lt;h3&gt;姓名: {{ user.name }}&lt;/h3&gt;
    &lt;h3&gt;年龄: {{ user.age }}&lt;/h3&gt;
    &lt;h3&gt;老婆: {{ user.wife.name }}&lt;/h3&gt;
    &lt;h3&gt;车: {{ user.car.join(&quot;、&quot;) }}&lt;/h3&gt;
    &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, reactive } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        let obj = {
            name: &quot;小明&quot;,
            age: 20,
            car: [&quot;奔驰&quot;, &quot;奥迪&quot;],
            wife: {
                name: &quot;小红&quot;,
                age: 18,
            },
        };
        let user = reactive(obj);
        const update = () =&gt; {
            user.age = 25;
            user.wife.age = 23;
            user.car.push(&quot;玛莎拉蒂&quot;, &quot;保时捷&quot;);
        };
        return {
            user,
            update,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h3 id="4、vue2-与-vue3-的响应式比较">4、Vue2 与 Vue3 的响应式比较</h3>
<h4 id="vue2-的响应式">vue2 的响应式</h4>
<ul>
<li><p>核心:</p>
<ul>
<li>对象: 通过 defineProperty 对对象的已有属性值的读取和修改进行劫持(监视/拦截)</li>
<li>数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li>对象直接新添加的属性或删除已有属性, 界面不会自动更新</li>
<li>直接通过下标替换元素或更新 length, 界面不会自动更新 arr[1] = {}</li>
</ul>
</li>
</ul>
<h4 id="vue3-的响应式">Vue3 的响应式</h4>
<ul>
<li>核心:<ul>
<li>通过 Proxy(代理): 拦截对 data 任意属性的任意(13 种)操作, 包括属性值的读写, 属性的添加, 属性的删除等...</li>
<li>通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作</li>
<li>文档:<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p> <strong>示例代码</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 目标对象</span>
<span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小憨憨&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,
    <span class="hljs-attr">wife</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;你猜&quot;</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,
    },
};

<span class="hljs-comment">// 把目标对象变成代理对象</span>
<span class="hljs-keyword">let</span> proxyUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, {
    <span class="hljs-comment">// 获取目标对象上的属性</span>
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;get方法调用了&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop);
    },
    <span class="hljs-comment">// 修改或添加目标对象上的属性</span>
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, val</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set方法调用了&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, val);
    },
    <span class="hljs-comment">// 删除某个目标对象的属性</span>
    <span class="hljs-title function_">defineProperty</span>(<span class="hljs-params">target, prop</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;delete方法被调用了&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, prop);
    },
});

<span class="hljs-comment">// 通过代理对象获取目标对象中的某个属性值</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyUser.<span class="hljs-property">name</span>);

proxyUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;陆憨憨&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);

proxyUser.<span class="hljs-property">gender</span> = <span class="hljs-string">&quot;男&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);

<span class="hljs-keyword">delete</span> proxyUser.<span class="hljs-property">age</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);
</code></pre>
<h3 id="5、setup-细节">5、setup 细节</h3>
<h4 id="setup-执行的时机">setup 执行的时机</h4>
<ul>
<li>在 beforeCreate 之前执行(一次), 此时组件对象还没有创建</li>
<li>this 是 undefined, 不能通过 this 来访问 data/computed/methods/props</li>
<li>其实所有的 composition API 相关回调函数中也都不可以</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="hljs language-vue">// App.vue
&lt;template&gt;
    &lt;h1&gt;setup执行时机&lt;/h1&gt;
    &lt;h3&gt;App父元素&lt;/h3&gt;
    &lt;h4&gt;msg: {{ msg }}&lt;/h4&gt;
    &lt;hr /&gt;
    &lt;Child :msg=&quot;msg&quot;&gt;&lt;/Child&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, ref } from &quot;vue&quot;;
import Child from &quot;./components/Child.vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    components: { Child },
    beforeCreate() {
        console.log(&quot;父组件中的beforeCreate&quot;);
    },
    setup() {
        console.log(&quot;父组件中的setup&quot;, `this是${this}`);

        let msg = ref(&quot;Hello World&quot;);

        return {
            msg,
        };
    },
});
&lt;/script&gt;

// Child.vue
&lt;template&gt;
    &lt;h3&gt;Child子元素&lt;/h3&gt;
    &lt;h4&gt;msg: {{ msg }}&lt;/h4&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;Child&quot;,
    props: [&quot;msg&quot;],
    beforeCreate() {
        console.log(&quot;子组件中的beforeCreate&quot;);
    },
    setup() {
        console.log(&quot;子组件中的setup&quot;, `this是${this}`);
    },
});
&lt;/script&gt;
</code></pre>
<h4 id="setup-的返回值">setup 的返回值</h4>
<ul>
<li>一般都返回一个对象: 为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法</li>
<li>返回对象中的属性会与 data 函数返回对象的属性合并成为组件对象的属性</li>
<li>返回对象中的方法会与 methods 中的方法合并成功组件对象的方法</li>
<li>如果有重名 setup 优先</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h1&gt;setup执行时机&lt;/h1&gt;
    &lt;h3&gt;App父元素&lt;/h3&gt;
    &lt;h4&gt;msg: {{ msg }}&lt;/h4&gt;
    &lt;hr /&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, ref } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        let msg = ref(&quot;setup中的msg&quot;);

        return {
            msg,
        };
    },
    data() {
        return {
            msg: &quot;data中的msg&quot;,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h4 id="setup-的参数">setup 的参数</h4>
<ul>
<li>setup(props, context) / setup(props, {attrs, slots, emit})</li>
<li>props: 包含 props 配置声明且传入了的所有属性的对象</li>
<li>attrs: 包含没有在 props 配置中声明的属性的对象, 相当于 this.$attrs</li>
<li>slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots</li>
<li>emit: 用来分发自定义事件的函数, 相当于 this.$emit</li>
</ul>
<p> <strong>示例代码</strong></p>
<pre><code class="hljs language-vue">// App.vue
&lt;template&gt;
    &lt;h1&gt;setup参数&lt;/h1&gt;
    &lt;h3&gt;App父元素&lt;/h3&gt;
    &lt;h4&gt;msg: {{ msg }}&lt;/h4&gt;
    &lt;hr /&gt;
    &lt;Child :msg=&quot;msg&quot; abc=&quot;abc&quot; @xxx=&quot;xxx&quot;&gt;&lt;/Child&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, ref } from &quot;vue&quot;;
import Child from &quot;./components/Child.vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    components: { Child },
    setup() {
        let msg = ref(&quot;setup中的msg&quot;);
        function xxx(txt: string) {
            msg.value += &quot;++&quot;;
        }

        return {
            msg,
            xxx,
        };
    },
});
&lt;/script&gt;

// Child.vue
&lt;template&gt;
    &lt;h3&gt;Child子元素&lt;/h3&gt;
    &lt;h4&gt;msg: {{ msg }}&lt;/h4&gt;
    &lt;button @click=&quot;emitXxx&quot;&gt;触发事件&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;Child&quot;,
    props: [&quot;msg&quot;],
    setup(props, { attrs, slots, emit }) {
        console.log(props, attrs, slots, emit);

        function emitXxx() {
            emit(&quot;xxx&quot;, &quot;++&quot;);
        }
        return {
            emitXxx,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h4 id="注意"><strong>注意:</strong></h4>
<ul>
<li>一般不要混合使用: methods 中可以访问 setup 提供的属性和方法, 但在 setup 方法中不能访问 data 和 methods</li>
<li>setup 不能是一个 async 函数: 因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性数据</li>
</ul>
<h3 id="6、reactive-与-ref-细节">6、reactive 与 ref 细节</h3>
<ul>
<li>是 Vue3 的 composition API 中 2 个最重要的响应式 API</li>
<li>ref 用来处理基本类型数据, reactive 用来处理对象(递归深度响应式)</li>
<li>ref 内部: 通过给 value 属性添加 getter/setter 来实现对数据的劫持</li>
<li>如果用 ref 对象/数组, 内部会自动将对象/数组转换为 reactive 的代理对象</li>
<li>reactive 内部: 通过使用 Proxy 来实现对对象内部所有数据的劫持, 并通过 Reflect 操作对象内部数据</li>
<li>ref 的数据操作: 在 js 中要.value, 在模板中不需要(内部解析模板时会自动添加.value)</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h1&gt;reactive与ref细节&lt;/h1&gt;
    &lt;h3&gt;ref基本数据类型：{{ m1 }}&lt;/h3&gt;
    &lt;h3&gt;ref引用数据类型：{{ m2.name }}&lt;/h3&gt;
    &lt;h3&gt;reactive引用数据类型：{{ m4.name }}&lt;/h3&gt;
    &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, reactive, ref } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        let m1 = ref(&quot;Hello World&quot;);
        let m2 = ref({
            name: &quot;小明&quot;,
            wife: {
                name: &quot;小红&quot;,
            },
        });
        let m4 = reactive({
            name: &quot;小白&quot;,
            wife: {
                name: &quot;小米&quot;,
            },
        });
        function update() {
            console.log(m1);
            console.log(m2);
            console.log(m4);
            m1.value += &quot;==&quot;;
            m2.value.name += &quot;==&quot;;
            m4.name += &quot;++&quot;;
        }
        return {
            m1,
            m2,
            m4,
            update,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h3 id="7、计算属性与监视">7、计算属性与监视</h3>
<ul>
<li><p>computed 函数:</p>
<ul>
<li>与 computed 配置功能一致</li>
<li>有 getter 和 setter</li>
</ul>
</li>
<li><p>watch 函数</p>
<ul>
<li>与 watch 配置功能一致</li>
<li>监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调</li>
<li>默认初始时不执行回调, 但可以通过配置 immediate 为 true, 来指定初始时立即执行第一次</li>
<li>通过配置 deep 为 true, 来指定深度监视</li>
</ul>
</li>
<li><p>watchEffect 函数</p>
<ul>
<li>不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据</li>
<li>默认初始时就会执行第一次, 从而可以收集需要监视的数据</li>
<li>监视数据发生变化时回调</li>
</ul>
</li>
</ul>
<p> <strong>示例代码</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h1&gt;计算属性和监视&lt;/h1&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;姓名操作&lt;/legend&gt;
        姓氏:
        &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓氏&quot; v-model=&quot;user.firstName&quot; /&gt;
        &lt;hr /&gt;
        名字:
        &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;user.lastName&quot; /&gt;
    &lt;/fieldset&gt;
    &lt;br /&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;计算属性和监视的演示&lt;/legend&gt;
        姓名: &lt;input type=&quot;text&quot; placeholder=&quot;显示姓名&quot; v-model=&quot;fullName1&quot; /&gt;
        &lt;hr /&gt;
        姓名: &lt;input type=&quot;text&quot; placeholder=&quot;显示姓名&quot; v-model=&quot;fullName2&quot; /&gt;
        &lt;hr /&gt;
        姓名: &lt;input type=&quot;text&quot; placeholder=&quot;显示姓名&quot; v-model=&quot;fullName3&quot; /&gt;
    &lt;/fieldset&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import {
    defineComponent,
    computed,
    reactive,
    watch,
    ref,
    watchEffect,
} from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        let user = reactive({
            firstName: &quot;东方&quot;,
            lastName: &quot;不败&quot;,
        });

        // 显示第一个名字
        // 返回一个ref类型的对象
        let fullName1 = computed(() =&gt; {
            return user.firstName + &quot;_&quot; + user.lastName;
        });

        // 显示第二个名字
        let fullName2 = computed({
            get() {
                return user.firstName + &quot;_&quot; + user.lastName;
            },
            set(val: string) {
                let names = val.split(&quot;_&quot;);
                user.firstName = names[0];
                user.lastName = names[1];
            },
        });

        // 显示第三名字 watch实现
        // let fullName3 = ref(&quot;&quot;);
        // watch(
        //     user,
        //     ({ firstName, lastName }) =&gt; {
        //         fullName3.value = user.firstName + &quot;_&quot; + user.lastName;
        //     },
        //     { immediate: true, deep: true }
        // );
        // // immediate 默认会执行一次 watch， deep 深度监听
        // watch(fullName3, (val) =&gt; {
        //     let names = val.split(&quot;_&quot;);
        //     user.firstName = names[0];
        //     user.lastName = names[1];
        // });

        // 显示第三名字 watchEffect实现
        let fullName3 = ref(&quot;&quot;);
        watch(
            user,
            ({ firstName, lastName }) =&gt; {
                fullName3.value = user.firstName + &quot;_&quot; + user.lastName;
            },
            { immediate: true, deep: true }
        );
        watchEffect(() =&gt; {
            let names = fullName3.value.split(&quot;_&quot;);
            user.firstName = names[0];
            user.lastName = names[1];
        });

        watch([() =&gt; user.firstName, () =&gt; user.lastName, fullName3], () =&gt; {
            // 这里的代码就没有执行,fullName3是响应式的数据,但是,user.firstName,user.lastName不是响应式的数据
            console.log(&quot;====&quot;);
        });

        return {
            user,
            fullName1,
            fullName2,
            fullName3,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h3 id="8、生命周期">8、生命周期</h3>
<p><strong>Vue3.x 中的生命周期执行优先于 Vue2.x 中的生命周期。</strong></p>
<h4 id="与-2x-版本生命周期相对应的组合式-api"><strong>与 2.x 版本生命周期相对应的组合式 API</strong></h4>
<table>
<thead>
<tr>
<th>Vue2.x</th>
<th>Vue3.x</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>setup()</td>
<td>数据加载前</td>
</tr>
<tr>
<td>created</td>
<td>setup()</td>
<td>数据加载后</td>
</tr>
<tr>
<td>beforeMount</td>
<td>onBeforeMount()</td>
<td>页面挂载前</td>
</tr>
<tr>
<td>mounted</td>
<td>onMounted()</td>
<td>页面挂载后</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeUpdate()</td>
<td>数据更新前</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated()</td>
<td>数据更新后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>onBeforeUnmount()</td>
<td>页面卸载前</td>
</tr>
<tr>
<td>destroyed</td>
<td>onUnmounted()</td>
<td>页面卸载后</td>
</tr>
<tr>
<td>errorCaptured</td>
<td>onErrorCaptured()</td>
<td>子组件错误捕获时</td>
</tr>
</tbody></table>
<h4 id="新增的钩子函数"><strong>新增的钩子函数</strong></h4>
<ul>
<li>组合式 API 还提供了以下调试钩子函数：<ul>
<li>onRenderTracked：跟踪虚拟 DOM 重新渲染时调用。</li>
<li>onRenderTriggered：当虚拟 DOM 重新渲染被触发时调用。</li>
</ul>
</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="hljs language-vue">// App.vue&lt;template&gt;
    &lt;h1&gt;生命周期&lt;/h1&gt;
    &lt;h3&gt;App&lt;/h3&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示隐藏&lt;/button&gt;
    &lt;hr /&gt;
    &lt;Child v-if=&quot;isShow&quot; /&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, ref } from &quot;vue&quot;;
import Child from &quot;./components/Child.vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    components: { Child },
    setup() {
        let isShow = ref(true);
        return {
            isShow,
        };
    },
});
&lt;/script&gt;

// Child.vue
&lt;template&gt;
    &lt;h3&gt;Child&lt;/h3&gt;
    &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;
    &lt;h3&gt;msg: {{ msg }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import {
    defineComponent,
    onBeforeMount,
    onBeforeUnmount,
    onBeforeUpdate,
    onMounted,
    onUnmounted,
    onUpdated,
    ref,
} from &quot;vue&quot;;

export default defineComponent({
    name: &quot;Child&quot;,
    // Vue2.x中的生命周期
    beforeCreate() {
        console.log(&quot;Vue2.x中的 beforeCreate ...&quot;);
    },
    created() {
        console.log(&quot;Vue2.x中的 created ...&quot;);
    },
    beforeMount() {
        console.log(&quot;Vue2.x中的 beforeMount ...&quot;);
    },
    mounted() {
        console.log(&quot;Vue2.x中的 mounted ...&quot;);
    },
    beforeUpdate() {
        console.log(&quot;Vue2.x中的 beforeUpdate ...&quot;);
    },
    updated() {
        console.log(&quot;Vue2.x中的 updated ...&quot;);
    },
    beforeUnmount() {
        console.log(&quot;Vue2.x中的 beforeUnmount ...&quot;);
    },
    unmounted() {
        console.log(&quot;Vue2.x中的 unmounted ...&quot;);
    },
    setup() {
        // Vue3.x中的生命周期
        console.log(&quot;Vue3.x中的 setup ...&quot;);
        onBeforeMount(() =&gt; console.log(&quot;Vue3.x中的 onBeforeMount ...&quot;));
        onMounted(() =&gt; console.log(&quot;Vue3.x中的 onMounted ...&quot;));
        onBeforeUpdate(() =&gt; console.log(&quot;Vue3.x中的 onBeforeUpdate ...&quot;));
        onUpdated(() =&gt; console.log(&quot;Vue3.x中的 onUpdated ...&quot;));
        onBeforeUnmount(() =&gt; console.log(&quot;Vue3.x中的 onBeforeUnmount ...&quot;));
        onUnmounted(() =&gt; console.log(&quot;Vue3.x中的 onUnmounted ...&quot;));

        let msg = ref(&quot;数据更新了&quot;);
        function update() {
            msg.value += &quot;+++&quot;;
        }
        return {
            msg,
            update,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h3 id="9、自定义-hook-函数">9、自定义 hook 函数</h3>
<ul>
<li>使用 Vue3 的组合 API 封装的可复用的功能函数</li>
<li>自定义 hook 的作用类似于 vue2 中的 mixin 技术</li>
<li>自定义 Hook 的优势: 很清楚复用功能代码的来源, 更清楚易懂</li>
</ul>
<p><strong>需求 1: 收集用户鼠标点击的页面坐标</strong></p>
<p><strong>示例代码</strong></p>
<p>./hooks/useMousePosition.ts</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { onBeforeUnmount, onMounted, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlerClick</span> = (<span class="hljs-params">e: MouseEvent</span>) =&gt; {
        x.<span class="hljs-property">value</span> = e.<span class="hljs-property">pageX</span>;
        y.<span class="hljs-property">value</span> = e.<span class="hljs-property">pageY</span>;
    };
    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handlerClick);
    });
    <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handlerClick);
    });
    <span class="hljs-keyword">return</span> {
        x,
        y,
    };
}
</code></pre>
<p>App.vue</p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h1&gt;自定义hook函数&lt;/h1&gt;
    &lt;h3&gt;X坐标：{{ x }}&lt;/h3&gt;
    &lt;h3&gt;Y坐标：{{ y }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, onMounted, ref } from &quot;vue&quot;;
import useMousePosition from &quot;./hooks/useMousePosition&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        const { x, y } = useMousePosition();
        return {
            x,
            y,
        };
    },
});
&lt;/script&gt;
</code></pre>
<p><strong>需求 2: 封装发 ajax 请求的 hook 函数, 利用 TS 泛型强化类型检查</strong></p>
<p><strong>示例代码</strong></p>
<p>./hooks/useRequest.ts</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> useRequest&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">const</span> result = ref&lt;T | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">const</span> errMsg = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);

    axios
        .<span class="hljs-title function_">get</span>(url)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
                result.<span class="hljs-property">value</span> = res.<span class="hljs-property">data</span>;
            }, <span class="hljs-number">2000</span>);
        })
        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
            loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
            errMsg.<span class="hljs-property">value</span> = err.<span class="hljs-property">message</span> || <span class="hljs-string">&quot;未知错误&quot;</span>;
        });

    <span class="hljs-keyword">return</span> {
        loading,
        result,
        errMsg,
    };
}
</code></pre>
<p>App.vue</p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h3&gt;作者信息&lt;/h3&gt;
    &lt;h4 v-if=&quot;loading1&quot;&gt;LOADING......&lt;/h4&gt;
    &lt;div v-else&gt;
        &lt;p&gt;姓名：{{ result1.name }}&lt;/p&gt;
        &lt;p&gt;性别：{{ result1.gender }}&lt;/p&gt;
        &lt;p&gt;年龄：{{ result1.age }}&lt;/p&gt;
    &lt;/div&gt;
    &lt;hr /&gt;
    &lt;h3&gt;书本名称&lt;/h3&gt;
    &lt;h4 v-if=&quot;loading2&quot;&gt;LOADING......&lt;/h4&gt;
    &lt;div v-else&gt;
        &lt;ul v-for=&quot;(item, index) in result2&quot; :key=&quot;index&quot;&gt;
            &lt;li&gt;书名：{{ item.name }}&lt;/li&gt;
            &lt;li&gt;价格：{{ item.price }}&lt;/li&gt;
            &lt;li&gt;分类：{{ item.category }}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, watch } from &quot;vue&quot;;
import useMousePosition from &quot;./hooks/useMousePosition&quot;;
import useRequest from &quot;./hooks/useRequest&quot;;

interface User {
    name: string;
    age: number;
    gender: string;
}

interface Book {
    name: string;
    price: number;
    ctaegory: string;
}

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        const { x, y } = useMousePosition();
        const { loading: loading1, result: result1 } = useRequest&lt;User&gt;(
            &quot;/data/user.json&quot;
        );
        const { loading: loading2, result: result2 } = useRequest&lt;Book[]&gt;(
            &quot;/data/books.json&quot;
        );

        watch(result2, () =&gt; {
            if (result2.value) {
                console.log(result2.value.length);
            }
        });

        return {
            x,
            y,
            result1,
            loading1,
            result2,
            loading2,
        };
    },
});
&lt;/script&gt;
</code></pre>
<h3 id="10、torefs">10、toRefs</h3>
<ul>
<li>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref</li>
<li>应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用</li>
<li>问题: reactive 对象取出的所有属性值都是非响应式的</li>
<li>解决: 利用 toRefs 可以将一个响应式 reactive 对象的所有原始属性转换为响应式的 ref 属性</li>
</ul>
<p> <strong>示例代码</strong></p>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h2&gt;toRefs&lt;/h2&gt;
    &lt;h3&gt;foo: {{ foo }}&lt;/h3&gt;
    &lt;h3&gt;bar: {{ bar }}&lt;/h3&gt;
    &lt;h3&gt;foo2: {{ foo2 }}&lt;/h3&gt;
    &lt;h3&gt;bar2: {{ bar2 }}&lt;/h3&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, reactive, toRefs } from &quot;vue&quot;;

export default defineComponent({
    setup() {
        const state = reactive({
            foo: &quot;a&quot;,
            bar: &quot;b&quot;,
        });

        const stateAsRefs = toRefs(state);

        setTimeout(() =&gt; {
            state.foo += &quot;++&quot;;
            state.bar += &quot;++&quot;;
        }, 2000);

        const { foo2, bar2 } = useReatureX();

        return {
            // ...state,
            ...stateAsRefs,
            foo2,
            bar2,
        };
    },
});
function useReatureX() {
    const state = reactive({
        foo2: &quot;a&quot;,
        bar2: &quot;b&quot;,
    });

    setTimeout(() =&gt; {
        state.foo2 += &quot;++&quot;;
        state.bar2 += &quot;++&quot;;
    }, 2000);

    return toRefs(state);
}
&lt;/script&gt;
</code></pre>
<h3 id="11、ref-获取元素">11、ref 获取元素</h3>
<ul>
<li>利用 ref 函数获取组件中的标签元素</li>
<li>功能需求: 让输入框自动获取焦点</li>
</ul>
<pre><code class="hljs language-vue">&lt;template&gt;
    &lt;h1&gt;ref 获取元素&lt;/h1&gt;
    &lt;input type=&quot;text&quot; /&gt;
    &lt;hr /&gt;
    &lt;input type=&quot;text&quot; ref=&quot;inputRef&quot; /&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, onMounted, ref } from &quot;vue&quot;;

export default defineComponent({
    name: &quot;App&quot;,
    setup() {
        const inputRef = ref&lt;HTMLElement | null&gt;(null);

        onMounted(() =&gt; {
            inputRef.value &amp;&amp; inputRef.value.focus();
        });
        return {
            inputRef,
        };
    },
});
&lt;/script&gt;
</code></pre>
</div>
        
      </div>
    </div>
  </body>
</html>
